<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Fri Apr 19 17:25:59 2019 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERL</title>

</head>
<body>

<h1 align="center">PERL</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perl &minus;
Practical Extraction and Report Language</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>perl</b>
[options] filename args</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><i>Perl</i> is
an interpreted language optimized for scanning arbitrary
text files, extracting information from those text files,
and printing reports based on that information. It&rsquo;s
also a good language for many system management tasks. The
language is intended to be practical (easy to use,
efficient, complete) rather than beautiful (tiny, elegant,
minimal). It combines (in the author&rsquo;s opinion,
anyway) some of the best features of C, <i>sed</i>,
<i>awk</i>, and <i>sh</i>, so people familiar with those
languages should have little difficulty with it. (Language
historians will also note some vestiges of <i>csh</i>,
Pascal, and even BASIC-PLUS.) Expression syntax corresponds
quite closely to C expression syntax. Unlike most Unix
utilities, <i>perl</i> does not arbitrarily limit the size
of your data--if you&rsquo;ve got the memory, <i>perl</i>
can slurp in your whole file as a single string. Recursion
is of unlimited depth. And the hash tables used by
associative arrays grow as necessary to prevent degraded
performance. <i>Perl</i> uses sophisticated pattern matching
techniques to scan large amounts of data very quickly.
Although optimized for scanning text, <i>perl</i> can also
deal with binary data, and can make dbm files look like
associative arrays (where dbm is available). Setuid
<i>perl</i> scripts are safer than C programs through a
dataflow tracing mechanism which prevents many stupid
security holes. If you have a problem that would ordinarily
use <i>sed</i> or <i>awk</i> or <i>sh</i>, but it exceeds
their capabilities or must run a little faster, and you
don&rsquo;t want to write the silly thing in C, then
<i>perl</i> may be for you. There are also translators to
turn your <i>sed</i> and <i>awk</i> scripts into <i>perl</i>
scripts. OK, enough hype.</p>

<p style="margin-left:11%; margin-top: 1em">Upon startup,
<i>perl</i> looks for your script in one of the following
places:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Specified line by line via <b>&minus;e</b> switches on
the command line.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Contained in the file specified by the first filename on
the command line. (Note that systems supporting the #!
notation invoke interpreters this way.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Passed in implicitly via standard input. This only works
if there are no filename arguments--to pass arguments to a
<i>stdin</i> script you must explicitly specify a &minus;
for the script name.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">After locating
your script, <i>perl</i> compiles it to an internal form. If
the script is syntactically correct, it is executed.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Options</b></p>

<p style="margin-left:11%; margin-top: 1em">Note: on first
reading this section may not make much sense to you.
It&rsquo;s here at the front for easy reference.</p>

<p style="margin-left:11%; margin-top: 1em">A
single-character option may be combined with the following
option, if any. This is particularly useful when invoking a
script using the #! construct which only allows one
argument. Example:</p>


<p style="margin-left:11%; margin-top: 1em">#!/usr/bin/perl
&minus;spi.bak # same as &minus;s &minus;p &minus;i.bak</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>...</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Options
include:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em"><b>&minus;a</b></p></td>
<td width="4%"></td>
<td width="82%">


<p style="margin-top: 1em">turns on autosplit mode when
used with a <b>&minus;n</b> or <b>&minus;p</b>. An implicit
split command to the @F array is done as the first thing
inside the implicit while loop produced by the
<b>&minus;n</b> or <b>&minus;p</b>.</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">perl &minus;ane
&acute;print pop(@F), &quot;\n&quot;;&acute;</p>

<p style="margin-left:18%; margin-top: 1em">is equivalent
to</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>while (&lt;&gt;) {</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>@F = split(&acute; &acute;);</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>print pop(@F), &quot;\n&quot;;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>}</p></td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em"><b>&minus;d</b></p></td>
<td width="4%"></td>
<td width="82%">


<p style="margin-top: 1em">runs the script under the perl
debugger. See the section on Debugging.</p></td></tr>
</table>


<p style="margin-left:11%;"><b>&minus;D</b><i>number</i></p>

<p style="margin-left:18%;">sets debugging flags. To watch
how it executes your script, use <b>&minus;D14</b>. (This
only works if debugging is compiled into your <i>perl</i>.)
Another nice value is &minus;D1024, which lists your
compiled syntax tree. And &minus;D512 displays compiled
regular expressions.</p>

<p style="margin-left:11%;"><b>&minus;e</b>
<i>commandline</i></p>

<p style="margin-left:18%;">may be used to enter one line
of script. Multiple <b>&minus;e</b> commands may be given to
build up a multi-line script. If <b>&minus;e</b> is given,
<i>perl</i> will not look for a script filename in the
argument list.</p>


<p style="margin-left:11%;"><b>&minus;i</b><i>extension</i></p>

<p style="margin-left:18%;">specifies that files processed
by the &lt;&gt; construct are to be edited in-place. It does
this by renaming the input file, opening the output file by
the same name, and selecting that output file as the default
for print statements. The extension, if supplied, is added
to the name of the old file to make a backup copy. If no
extension is supplied, no backup is made. Saying &quot;perl
&minus;p &minus;i.bak &minus;e &quot;s/foo/bar/;&quot; ...
&quot; is the same as using the script:</p>


<p style="margin-left:18%; margin-top: 1em">#!/usr/bin/perl
&minus;pi.bak</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>s/foo/bar/;</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">which is
equivalent to</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">


<p>#!/usr/bin/perl</p></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">


<p>while (&lt;&gt;) {</p></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="8%">
</td>
<td width="7%">


<p>if ($ARGV ne $oldargv) {</p></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="8%">
</td>
<td width="7%">
</td>
<td width="62%">


<p>rename($ARGV, $ARGV . &acute;.bak&acute;);</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="8%">
</td>
<td width="7%">
</td>
<td width="62%">


<p>open(ARGVOUT, &quot;&gt;$ARGV&quot;);</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="8%">
</td>
<td width="7%">
</td>
<td width="62%">


<p>select(ARGVOUT);</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="8%">
</td>
<td width="7%">
</td>
<td width="62%">


<p>$oldargv = $ARGV;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="8%">
</td>
<td width="7%">


<p>}</p></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="8%">
</td>
<td width="7%">


<p>s/foo/bar/;</p></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">


<p>}</p></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">


<p>continue {</p></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="8%">


<p>print;</p></td>
<td width="7%"></td>
<td width="62%">


<p># this prints to original filename</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">


<p>}</p></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">


<p>select(STDOUT);</p></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">except that the
<b>&minus;i</b> form doesn&rsquo;t need to compare $ARGV to
$oldargv to know when the filename has changed. It does,
however, use ARGVOUT for the selected filehandle. Note that
<i>STDOUT</i> is restored as the default output filehandle
after the loop.</p>

<p style="margin-left:18%; margin-top: 1em">You can use eof
to locate the end of each input file, in case you want to
append to each file, or reset line numbering (see example
under eof).</p>


<p style="margin-left:11%;"><b>&minus;I</b><i>directory</i></p>

<p style="margin-left:18%;">may be used in conjunction with
<b>&minus;P</b> to tell the C preprocessor where to look for
include files. By default /usr/include and /usr/lib/perl are
searched.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;n</b></p></td>
<td width="4%"></td>
<td width="82%">


<p>causes <i>perl</i> to assume the following loop around
your script, which makes it iterate over filename arguments
somewhat like &quot;sed &minus;n&quot; or <i>awk</i>:</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">while
(&lt;&gt;) {</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="8%">
</td>
<td width="7%">


<p>...</p></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="62%">


<p># your script goes here</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">


<p>}</p></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Note that the
lines are not printed by default. See <b>&minus;p</b> to
have lines printed. Here is an efficient way to delete all
files older than a week:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>find . &minus;mtime +7 &minus;print &#9130; perl
&minus;ne &acute;chop;unlink;&acute;</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">This is faster
than using the &minus;exec switch of find because you
don&rsquo;t have to start a process on every filename
found.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em"><b>&minus;p</b></p></td>
<td width="4%"></td>
<td width="82%">


<p style="margin-top: 1em">causes <i>perl</i> to assume the
following loop around your script, which makes it iterate
over filename arguments somewhat like <i>sed</i>:</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">while
(&lt;&gt;) {</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="8%">
</td>
<td width="7%">


<p>...</p></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="62%">


<p># your script goes here</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">


<p>} continue {</p></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="8%">
</td>
<td width="7%">


<p>print;</p></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">


<p>}</p></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Note that the
lines are printed automatically. To suppress printing use
the <b>&minus;n</b> switch. A <b>&minus;p</b> overrides a
<b>&minus;n</b> switch.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em"><b>&minus;P</b></p></td>
<td width="4%"></td>
<td width="82%">


<p style="margin-top: 1em">causes your script to be run
through the C preprocessor before compilation by
<i>perl</i>. (Since both comments and cpp directives begin
with the # character, you should avoid starting comments
with any words recognized by the C preprocessor such as
&quot;if&quot;, &quot;else&quot; or &quot;define&quot;.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;s</b></p></td>
<td width="4%"></td>
<td width="82%">


<p>enables some rudimentary switch parsing for switches on
the command line after the script name but before any
filename arguments (or before a &minus;&minus;). Any switch
found there is removed from @ARGV and sets the corresponding
variable in the <i>perl</i> script. The following script
prints &quot;true&quot; if and only if the script is invoked
with a &minus;xyz switch.</p></td></tr>
</table>


<p style="margin-left:18%; margin-top: 1em">#!/usr/bin/perl
&minus;s</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>if ($xyz) { print &quot;true\n&quot;; }</p></td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em"><b>&minus;S</b></p></td>
<td width="4%"></td>
<td width="82%">


<p style="margin-top: 1em">makes <i>perl</i> use the PATH
environment variable to search for the script (unless the
name of the script starts with a slash). Typically this is
used to emulate #! startup on machines that don&rsquo;t
support #!, in the following manner:</p></td></tr>
</table>


<p style="margin-left:18%; margin-top: 1em">#!/usr/bin/perl</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>eval &quot;exec /usr/bin/perl &minus;S $0 $*&quot;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>if $running_under_some_shell;</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">The system
ignores the first line and feeds the script to /bin/sh,
which proceeds to try to execute the <i>perl</i> script as a
shell script. The shell executes the second line as a normal
shell command, and thus starts up the <i>perl</i>
interpreter. On some systems $0 doesn&rsquo;t always contain
the full pathname, so the <b>&minus;S</b> tells <i>perl</i>
to search for the script if necessary. After <i>perl</i>
locates the script, it parses the lines and ignores them
because the variable $running_under_some_shell is never
true.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em"><b>&minus;u</b></p></td>
<td width="4%"></td>
<td width="82%">


<p style="margin-top: 1em">causes <i>perl</i> to dump core
after compiling your script. You can then take this core
dump and turn it into an executable file by using the undump
program (not supplied). This speeds startup at the expense
of some disk space (which you can minimize by stripping the
executable). (Still, a &quot;hello world&quot; executable
comes out to about 200K on my machine.) If you are going to
run your executable as a set-id program then you should
probably compile it using taintperl rather than normal perl.
If you want to execute a portion of your script before
dumping, use the dump operator instead.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;U</b></p></td>
<td width="4%"></td>
<td width="82%">


<p>allows <i>perl</i> to do unsafe operations. Currently
the only &quot;unsafe&quot; operation is the unlinking of
directories while running as superuser.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;v</b></p></td>
<td width="4%"></td>
<td width="82%">


<p>prints the version and patchlevel of your <i>perl</i>
executable.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>&minus;w</b></p></td>
<td width="4%"></td>
<td width="82%">


<p>prints warnings about identifiers that are mentioned
only once, and scalar variables that are used before being
set. Also warns about redefined subroutines, and references
to undefined filehandles or filehandles opened readonly that
you are attempting to write on. Also warns you if you use ==
on values that don&rsquo;t look like numbers, and if your
subroutines recurse more than 100 deep.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Data Types
and Objects</b></p>

<p style="margin-left:11%; margin-top: 1em"><i>Perl</i> has
three data types: scalars, arrays of scalars, and
associative arrays of scalars. Normal arrays are indexed by
number, and associative arrays by string.</p>

<p style="margin-left:11%; margin-top: 1em">The
interpretation of operations and values in perl sometimes
depends on the requirements of the context around the
operation or value. There are three major contexts: string,
numeric and array. Certain operations return array values in
contexts wanting an array, and scalar values otherwise. (If
this is true of an operation it will be mentioned in the
documentation for that operation.) Operations which return
scalars don&rsquo;t care whether the context is looking for
a string or a number, but scalar variables and values are
interpreted as strings or numbers as appropriate to the
context. A scalar is interpreted as TRUE in the boolean
sense if it is not the null string or 0. Booleans returned
by operators are 1 for true and &acute;0&acute; or
&acute;&acute; (the null string) for false.</p>

<p style="margin-left:11%; margin-top: 1em">There are
actually two varieties of null string: defined and
undefined. Undefined null strings are returned when there is
no real value for something, such as when there was an
error, or at end of file, or when you refer to an
uninitialized variable or element of an array. An undefined
null string may become defined the first time you access it,
but prior to that you can use the defined() operator to
determine whether the value is defined or not.</p>

<p style="margin-left:11%; margin-top: 1em">References to
scalar variables always begin with &rsquo;$&rsquo;, even
when referring to a scalar that is part of an array.
Thus:</p>

<p style="margin-left:11%; margin-top: 1em">$days # a
simple scalar variable</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p>$days[28]</p><td width="17%"></td>
<td width="-9%"></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="69%">


<p># 29th element of array @days</p></td></tr>
</table>

<p style="margin-left:11%;">$days{&acute;Feb&acute;} # one
value from an associative array</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p>$#days</p><td width="17%"></td>
<td width="-9%"></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="69%">


<p># last index of array @days</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">but entire
arrays or array slices are denoted by &rsquo;@&rsquo;:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p>@days</p><td width="17%"></td>
<td width="-9%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p># ($days[0], $days[1],... $days[n])</p></td></tr>
</table>

<p style="margin-left:11%;">@days[3,4,5] # same as
@days[3..5] <br>
@days{&rsquo;a&rsquo;,&rsquo;c&rsquo;} # same as
($days{&rsquo;a&rsquo;},$days{&rsquo;c&rsquo;})</p>

<p style="margin-left:11%; margin-top: 1em">and entire
associative arrays are denoted by &rsquo;%&rsquo;:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p>%days</p><td width="17%"></td>
<td width="-9%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p># (key1, val1, key2, val2 ...)</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Any of these
eight constructs may serve as an lvalue, that is, may be
assigned to. (It also turns out that an assignment is itself
an lvalue in certain contexts--see examples under s, tr and
chop.) Assignment to a scalar evaluates the righthand side
in a scalar context, while assignment to an array or array
slice evaluates the righthand side in an array context.</p>

<p style="margin-left:11%; margin-top: 1em">You may find
the length of array @days by evaluating &quot;$#days&quot;,
as in <i>csh</i>. (Actually, it&rsquo;s not the length of
the array, it&rsquo;s the subscript of the last element,
since there is (ordinarily) a 0th element.) Assigning to
$#days changes the length of the array. Shortening an array
by this method does not actually destroy any values.
Lengthening an array that was previously shortened recovers
the values that were in those elements. You can also gain
some measure of efficiency by preextending an array that is
going to get big. (You can also extend an array by assigning
to an element that is off the end of the array. This differs
from assigning to $#whatever in that intervening values are
set to null rather than recovered.) You can truncate an
array down to nothing by assigning the null list () to it.
The following are exactly equivalent</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>@whatever = ();</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>$#whatever = $[ &minus; 1;</p></td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em">Multi-dimensional
arrays are not directly supported, but see the discussion of
the $; variable later for a means of emulating multiple
subscripts with an associative array.</p>

<p style="margin-left:11%; margin-top: 1em">Every data type
has its own namespace. You can, without fear of conflict,
use the same name for a scalar variable, an array, an
associative array, a filehandle, a subroutine name, and/or a
label. Since variable and array references always start with
&rsquo;$&rsquo;, &rsquo;@&rsquo;, or &rsquo;%&rsquo;, the
&quot;reserved&quot; words aren&rsquo;t in fact reserved
with respect to variable names. (They ARE reserved with
respect to labels and filehandles, however, which
don&rsquo;t have an initial special character. Hint: you
could say open(LOG,&acute;logfile&acute;) rather than
open(log,&acute;logfile&acute;). Using uppercase filehandles
also improves readability and protects you from conflict
with future reserved words.) Case IS
significant--&quot;FOO&quot;, &quot;Foo&quot; and
&quot;foo&quot; are all different names. Names which start
with a letter may also contain digits and underscores. Names
which do not start with a letter are limited to one
character, e.g. &quot;$%&quot; or &quot;$$&quot;. (Most of
the one character names have a predefined significance to
<i>perl</i>. More later.)</p>

<p style="margin-left:11%; margin-top: 1em">Numeric
literals are specified in any of the usual floating point or
integer formats:</p>

<p style="margin-left:11%; margin-top: 1em">12345 <br>
12345.67 <br>
.23E-10</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p>0xffff</p><td width="17%"></td>
<td width="-9%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">


<p># hex <br>
0377</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="-9%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">


<p># octal</p></td>
<td width="69%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">String literals
are delimited by either single or double quotes. They work
much like shell quotes: double-quoted string literals are
subject to backslash and variable substitution;
single-quoted strings are not (except for \&acute; and \\).
The usual backslash rules apply for making characters such
as newline, tab, etc. You can also embed newlines directly
in your strings, i.e. they can end on a different line than
they begin. This is nice, but if you forget your trailing
quote, the error will not be reported until <i>perl</i>
finds another line containing the quote character, which may
be much further on in the script. Variable substitution
inside strings is limited to scalar variables, normal array
values, and array slices. (In other words, identifiers
beginning with $ or @, followed by an optional bracketed
expression as a subscript.) The following code segment
prints out &quot;The price is $100.&quot;</p>

<p style="margin-left:11%; margin-top: 1em">$Price =
&acute;$100&acute;; # not interpreted <br>
print &quot;The price is $Price.\n&quot;;# interpreted</p>

<p style="margin-left:11%; margin-top: 1em">Note that you
can put curly brackets around the identifier to delimit it
from following alphanumerics.</p>

<p style="margin-left:11%; margin-top: 1em">Array values
are interpolated into double-quoted strings by joining all
the elements of the array with the delimiter specified in
the $&quot; variable, space by default. (Since in versions
of perl prior to 3.0 the @ character was not a metacharacter
in double-quoted strings, the interpolation of @array,
$array[EXPR], @array[LIST], $array{EXPR}, or @array{LIST}
only happens if array is referenced elsewhere in the program
or is predefined.) The following are equivalent:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>$temp = join($&quot;,@ARGV);</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>system &quot;echo $temp&quot;;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>system &quot;echo @ARGV&quot;;</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Within search
patterns (which also undergo double-quoteish substitution)
there is a bad ambiguity: Is /$foo[bar]/ to be interpreted
as /${foo}[bar]/ (where [bar] is a character class for the
regular expression) or as /${foo[bar]}/ (where [bar] is the
subscript to array @foo)? If @foo doesn&rsquo;t otherwise
exist, then it&rsquo;s obviously a character class. If @foo
exists, perl takes a good guess about [bar], and is almost
always right. If it does guess wrong, or if you&rsquo;re
just plain paranoid, you can force the correct
interpretation with curly brackets as above.</p>

<p style="margin-left:11%; margin-top: 1em">A line-oriented
form of quoting is based on the shell here-is syntax.
Following a &lt;&lt; you specify a string to terminate the
quoted material, and all lines following the current line
down to the terminating string are the value of the item.
The terminating string may be either an identifier (a word),
or some quoted text. If quoted, the type of quotes you use
determines the treatment of the text, just as in regular
quoting. An unquoted identifier works like double quotes.
There must be no space between the &lt;&lt; and the
identifier. (If you put a space it will be treated as a null
identifier, which is valid, and matches the first blank
line--see Merry Christmas example below.) The terminating
string must appear by itself (unquoted and with no
surrounding whitespace) on the terminating line.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="16%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>print &lt;&lt;EOF;</p></td>
<td width="16%"></td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="54%">


<p># same as above</p></td></tr>
</table>

<p style="margin-left:11%;">The price is $Price. <br>
EOF</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="16%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>print &lt;&lt;&quot;EOF&quot;;</p></td>
<td width="16%"></td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="54%">


<p># same as above</p></td></tr>
</table>

<p style="margin-left:11%;">The price is $Price. <br>
EOF</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="16%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>print &lt;&lt; x 10;</p></td>
<td width="16%"></td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="54%">


<p># null identifier is delimiter</p></td></tr>
</table>

<p style="margin-left:11%;">Merry Christmas!</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="16%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>print &lt;&lt;&lsquo;EOC&lsquo;;</p></td>
<td width="16%"></td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="54%">


<p># execute commands</p></td></tr>
</table>

<p style="margin-left:11%;">echo hi there <br>
echo lo there <br>
EOC</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="23%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>print &lt;&lt;foo, &lt;&lt;bar;</p></td>
<td width="23%"></td>
<td width="8%"></td>
<td width="54%">


<p># you can stack them</p></td></tr>
</table>

<p style="margin-left:11%;">I said foo. <br>
foo <br>
I said bar. <br>
bar</p>

<p style="margin-left:11%; margin-top: 1em">Array literals
are denoted by separating individual values by commas, and
enclosing the list in parentheses. In a context not
requiring an array value, the value of the array literal is
the value of the final element, as in the C comma operator.
For example,</p>

<p style="margin-left:11%; margin-top: 1em">@foo =
(&acute;cc&acute;, &acute;&minus;E&acute;, $bar);</p>

<p style="margin-left:11%; margin-top: 1em">assigns the
entire array value to array foo, but</p>

<p style="margin-left:11%; margin-top: 1em">$foo =
(&acute;cc&acute;, &acute;&minus;E&acute;, $bar);</p>

<p style="margin-left:11%; margin-top: 1em">assigns the
value of variable bar to variable foo. Array lists may be
assigned to if and only if each element of the list is an
lvalue:</p>

<p style="margin-left:11%; margin-top: 1em">($a, $b, $c) =
(1, 2, 3);</p>


<p style="margin-left:11%; margin-top: 1em">($map{&acute;red&acute;},
$map{&acute;blue&acute;}, $map{&acute;green&acute;}) =
(0x00f, 0x0f0, 0xf00);</p>

<p style="margin-left:11%; margin-top: 1em">The final
element may be an array or an associative array:</p>

<p style="margin-left:11%; margin-top: 1em">($a, $b, @rest)
= split; <br>
local($a, $b, %rest) = @_;</p>

<p style="margin-left:11%; margin-top: 1em">You can
actually put an array anywhere in the list, but the first
array in the list will soak up all the values, and anything
after it will get a null value. This may be useful in a
local().</p>

<p style="margin-left:11%; margin-top: 1em">An associative
array literal contains pairs of values to be interpreted as
a key and a value:</p>

<p style="margin-left:11%; margin-top: 1em"># same as map
assignment above <br>
%map =
(&rsquo;red&rsquo;,0x00f,&rsquo;blue&rsquo;,0x0f0,&rsquo;green&rsquo;,0xf00);</p>

<p style="margin-left:11%; margin-top: 1em">Array
assignment in a scalar context returns the number of
elements produced by the expression on the right side of the
assignment:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="39%"></td>
<td width="8%"></td>
<td width="38%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>$x = (($foo,$bar) = (3,2,1));</p></td>
<td width="39%"></td>
<td width="8%"></td>
<td width="38%">


<p># set $x to 3, not 2</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">There are
several other pseudo-literals that you should know about. If
a string is enclosed by backticks (grave accents), it first
undergoes variable substitution just like a double quoted
string. It is then interpreted as a command, and the output
of that command is the value of the pseudo-literal, like in
a shell. The command is executed each time the
pseudo-literal is evaluated. The status value of the command
is returned in $? (see Predefined Names for the
interpretation of $?). Unlike in <i>csh</i>, no translation
is done on the return data--newlines remain newlines. Unlike
in any of the shells, single quotes do not hide variable
names in the command from interpretation. To pass a $
through to the shell you need to hide it with a
backslash.</p>

<p style="margin-left:11%; margin-top: 1em">Evaluating a
filehandle in angle brackets yields the next line from that
file (newline included, so it&rsquo;s never false until EOF,
at which time an undefined value is returned). Ordinarily
you must assign that value to a variable, but there is one
situation where in which an automatic assignment happens. If
(and only if) the input symbol is the only thing inside the
conditional of a <i>while</i> loop, the value is
automatically assigned to the variable &quot;$_&quot;. (This
may seem like an odd thing to you, but you&rsquo;ll use the
construct in almost every <i>perl</i> script you write.)
Anyway, the following lines are equivalent to each
other:</p>

<p style="margin-left:11%; margin-top: 1em">while ($_ =
&lt;STDIN&gt;) { print; } <br>
while (&lt;STDIN&gt;) { print; } <br>
for (;&lt;STDIN&gt;;) { print; } <br>
print while $_ = &lt;STDIN&gt;; <br>
print while &lt;STDIN&gt;;</p>

<p style="margin-left:11%; margin-top: 1em">The filehandles
<i>STDIN</i>, <i>STDOUT</i> and <i>STDERR</i> are
predefined. (The filehandles <i>stdin</i>, <i>stdout</i> and
<i>stderr</i> will also work except in packages, where they
would be interpreted as local identifiers rather than
global.) Additional filehandles may be created with the
<i>open</i> function.</p>

<p style="margin-left:11%; margin-top: 1em">If a
&lt;FILEHANDLE&gt; is used in a context that is looking for
an array, an array consisting of all the input lines is
returned, one line per array element. It&rsquo;s easy to
make a LARGE data space this way, so use with care.</p>

<p style="margin-left:11%; margin-top: 1em">The null
filehandle &lt;&gt; is special and can be used to emulate
the behavior of <i>sed</i> and <i>awk</i>. Input from
&lt;&gt; comes either from standard input, or from each file
listed on the command line. Here&rsquo;s how it works: the
first time &lt;&gt; is evaluated, the ARGV array is checked,
and if it is null, $ARGV[0] is set to &acute;-&acute;, which
when opened gives you standard input. The ARGV array is then
processed as a list of filenames. The loop</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>while (&lt;&gt;) {</p></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">


<p>...</p></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="54%">


<p># code for each line</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>}</p></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">is equivalent
to</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>unshift(@ARGV, &acute;&minus;&acute;) if $#ARGV &lt;
$[;</p> </td>
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>while ($ARGV = shift) {</p></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">


<p>open(ARGV, $ARGV);</p></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">


<p>while (&lt;ARGV&gt;) {</p></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">
</td>
<td width="7%">


<p>...</p></td>
<td width="8%">
</td>
<td width="54%">


<p># code for each line</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">


<p>}</p></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>}</p></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">except that it
isn&rsquo;t as cumbersome to say. It really does shift array
ARGV and put the current filename into variable ARGV. It
also uses filehandle ARGV internally. You can modify @ARGV
before the first &lt;&gt; as long as you leave the first
filename at the beginning of the array. Line numbers ($.)
continue as if the input was one big happy file. (But see
example under eof for how to reset line numbers on each
file.)</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
set @ARGV to your own list of files, go right ahead. If you
want to pass switches into your script, you can put a loop
on the front like this:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>while ($_ = $ARGV[0], /^&minus;/) {</p></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">


<p>shift;</p></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>last if /^&minus;&minus;$/;</p></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">


<p>/^&minus;D(.*)/ &amp;&amp; ($debug = $1);</p></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">


<p>/^&minus;v/ &amp;&amp; $verbose++;</p></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">


<p>...</p></td>
<td width="7%">
</td>
<td width="62%">


<p># other switches</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>}</p></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>while (&lt;&gt;) {</p></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">


<p>...</p></td>
<td width="7%">
</td>
<td width="62%">


<p># code for each line</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>}</p></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The &lt;&gt;
symbol will return FALSE only once. If you call it again
after this it will assume you are processing another @ARGV
list, and if you haven&rsquo;t set @ARGV, will input from
<i>STDIN</i>.</p>

<p style="margin-left:11%; margin-top: 1em">If the string
inside the angle brackets is a reference to a scalar
variable (e.g. &lt;$foo&gt;), then that variable contains
the name of the filehandle to input from.</p>

<p style="margin-left:11%; margin-top: 1em">If the string
inside angle brackets is not a filehandle, it is interpreted
as a filename pattern to be globbed, and either an array of
filenames or the next filename in the list is returned,
depending on context. One level of $ interpretation is done
first, but you can&rsquo;t say &lt;$foo&gt; because
that&rsquo;s an indirect filehandle as explained in the
previous paragraph. You could insert curly brackets to force
interpretation as a filename glob: &lt;${foo}&gt;.
Example:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>while (&lt;*.c&gt;) {</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>chmod 0644, $_;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>}</p></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">is equivalent
to</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>open(foo, &quot;echo *.c &#9130; tr &minus;s &acute;
\t\r\f&acute;
&acute;\\012\\012\\012\\012&acute;&#9130;&quot;);</p> </td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>while (&lt;foo&gt;) {</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>chop;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>chmod 0644, $_;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>}</p></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">In fact,
it&rsquo;s currently implemented that way. (Which means it
will not work on filenames with spaces in them unless you
have /bin/csh on your machine.) Of course, the shortest way
to do the above is:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>chmod 0644, &lt;*.c&gt;;</p></td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>Syntax</b></p>

<p style="margin-left:11%; margin-top: 1em">A <i>perl</i>
script consists of a sequence of declarations and commands.
The only things that need to be declared in <i>perl</i> are
report formats and subroutines. See the sections below for
more information on those declarations. All uninitialized
objects user-created objects are assumed to start with a
null or 0 value until they are defined by some explicit
operation such as assignment. The sequence of commands is
executed just once, unlike in <i>sed</i> and <i>awk</i>
scripts, where the sequence of commands is executed for each
input line. While this means that you must explicitly loop
over the lines of your input file (or files), it also means
you have much more control over which files and which lines
you look at. (Actually, I&rsquo;m lying--it is possible to
do an implicit loop with either the <b>&minus;n</b> or
<b>&minus;p</b> switch.)</p>

<p style="margin-left:11%; margin-top: 1em">A declaration
can be put anywhere a command can, but has no effect on the
execution of the primary sequence of commands--declarations
all take effect at compile time. Typically all the
declarations are put at the beginning or the end of the
script.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Perl</i> is,
for the most part, a free-form language. (The only exception
to this is format declarations, for fairly obvious reasons.)
Comments are indicated by the # character, and extend to the
end of the line. If you attempt to use /* */ C comments, it
will be interpreted either as division or pattern matching,
depending on the context. So don&rsquo;t do that.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Compound
statements</b></p>

<p style="margin-left:11%; margin-top: 1em">In <i>perl</i>,
a sequence of commands may be treated as one command by
enclosing it in curly brackets. We will call this a
BLOCK.</p>

<p style="margin-left:11%; margin-top: 1em">The following
compound commands may be used to control flow:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>if (EXPR) BLOCK</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>if (EXPR) BLOCK else BLOCK</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>if (EXPR) BLOCK elsif (EXPR) BLOCK ... else BLOCK</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>LABEL while (EXPR) BLOCK</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>LABEL while (EXPR) BLOCK continue BLOCK</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>LABEL for (EXPR; EXPR; EXPR) BLOCK</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>LABEL foreach VAR (ARRAY) BLOCK</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>LABEL BLOCK continue BLOCK</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Note that,
unlike C and Pascal, these are defined in terms of BLOCKs,
not statements. This means that the curly brackets are
<i>required</i>--no dangling statements allowed. If you want
to write conditionals without curly brackets there are
several other ways to do it. The following all do the same
thing:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>if (!open(foo)) { die &quot;Can&rsquo;t open $foo:
$!&quot;; }</p></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="31%"></td>
<td width="8%"></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>die &quot;Can&rsquo;t open $foo: $!&quot; unless
open(foo);</p> </td>
<td width="8%"></td>
<td width="7%"></td>
<td width="31%"></td>
<td width="8%"></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>open(foo) &#9130;&#9130; die &quot;Can&rsquo;t open
$foo: $!&quot;;</p></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="31%"></td>
<td width="8%"></td>
<td width="23%">


<p># foo or bust!</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>open(foo) ? die &quot;Can&rsquo;t open $foo: $!&quot; :
&acute;hi mom&acute;;</p></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="31%"></td>
<td width="8%"></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">
</td>
<td width="7%">
</td>
<td width="31%"></td>
<td width="8%"></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="7%">


<p># a bit exotic, that last one</p></td>
<td width="31%"></td>
<td width="8%"></td>
<td width="23%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The <i>if</i>
statement is straightforward. Since BLOCKs are always
bounded by curly brackets, there is never any ambiguity
about which <i>if</i> an <i>else</i> goes with. If you use
<i>unless</i> in place of <i>if</i>, the sense of the test
is reversed.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>while</i> statement executes the block as long as the
expression is true (does not evaluate to the null string or
0). The LABEL is optional, and if present, consists of an
identifier followed by a colon. The LABEL identifies the
loop for the loop control statements <i>next</i>,
<i>last</i>, and <i>redo</i> (see below). If there is a
<i>continue</i> BLOCK, it is always executed just before the
conditional is about to be evaluated again, similarly to the
third part of a <i>for</i> loop in C. Thus it can be used to
increment a loop variable, even when the loop has been
continued via the <i>next</i> statement (similar to the C
&quot;continue&quot; statement).</p>

<p style="margin-left:11%; margin-top: 1em">If the word
<i>while</i> is replaced by the word <i>until</i>, the sense
of the test is reversed, but the conditional is still tested
before the first iteration.</p>

<p style="margin-left:11%; margin-top: 1em">In either the
<i>if</i> or the <i>while</i> statement, you may replace
&quot;(EXPR)&quot; with a BLOCK, and the conditional is true
if the value of the last command in that block is true.</p>

<p style="margin-left:11%; margin-top: 1em">The <i>for</i>
loop works exactly like the corresponding <i>while</i>
loop:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>for ($i = 1; $i &lt; 10; $i++) {</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>...</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>}</p></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">is the same
as</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>$i = 1;</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>while ($i &lt; 10) {</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>...</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>} continue {</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>$i++;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>}</p></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The foreach
loop iterates over a normal array value and sets the
variable VAR to be each element of the array in turn. The
&quot;foreach&quot; keyword is actually identical to the
&quot;for&quot; keyword, so you can use &quot;foreach&quot;
for readability or &quot;for&quot; for brevity. If VAR is
omitted, $_ is set to each value. If ARRAY is an actual
array (as opposed to an expression returning an array
value), you can modify each element of the array by
modifying VAR inside the loop. Examples:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>for (@ary) { s/foo/bar/; }</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>foreach $elem (@elements) {</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>$elem *= 2;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>}</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>for ((10,9,8,7,6,5,4,3,2,1,&acute;BOOM&acute;)) {</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>print $_, &quot;\n&quot;; sleep(1);</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>}</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>for (1..15) { print &quot;Merry Christmas\n&quot;; }</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>foreach $item (split(/:[\\\n:]*/,
$ENV{&acute;TERMCAP&acute;}) {</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>print &quot;Item: $item\n&quot;;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>}</p></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The BLOCK by
itself (labeled or not) is equivalent to a loop that
executes once. Thus you can use any of the loop control
statements in it to leave or restart the block. The
<i>continue</i> block is optional. This construct is
particularly nice for doing case structures.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>foo: {</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>if (/^abc/) { $abc = 1; last foo; }</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>if (/^def/) { $def = 1; last foo; }</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>if (/^xyz/) { $xyz = 1; last foo; }</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>$nothing = 1;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>}</p></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">There is no
official switch statement in perl, because there are already
several ways to write the equivalent. In addition to the
above, you could write</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>foo: {</p></td>
<td width="23%"></td>
<td width="8%"></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="23%"></td>
<td width="8%"></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>$abc = 1, last foo</p></td>
<td width="23%"></td>
<td width="8%"></td>
<td width="46%">


<p>if /^abc/;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="23%"></td>
<td width="8%"></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>$def = 1, last foo</p></td>
<td width="23%"></td>
<td width="8%"></td>
<td width="46%">


<p>if /^def/;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="23%"></td>
<td width="8%"></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>$xyz = 1, last foo</p></td>
<td width="23%"></td>
<td width="8%"></td>
<td width="46%">


<p>if /^xyz/;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="23%"></td>
<td width="8%"></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>$nothing = 1;</p></td>
<td width="23%"></td>
<td width="8%"></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>}</p></td>
<td width="23%"></td>
<td width="8%"></td>
<td width="46%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">or</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>foo: {</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>/^abc/ &amp;&amp; do { $abc = 1; last foo; }</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>/^def/ &amp;&amp; do { $def = 1; last foo; }</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>/^xyz/ &amp;&amp; do { $xyz = 1; last foo; }</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>$nothing = 1;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>}</p></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">or</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>foo: {</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>/^abc/ &amp;&amp; ($abc = 1, last foo);</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>/^def/ &amp;&amp; ($def = 1, last foo);</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>/^xyz/ &amp;&amp; ($xyz = 1, last foo);</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>$nothing = 1;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>}</p></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">or even</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>if (/^abc/)</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>{ $abc = 1; last foo; }</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>elsif (/^def/)</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>{ $def = 1; last foo; }</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>elsif (/^xyz/)</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>{ $xyz = 1; last foo; }</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>else</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>{$nothing = 1;}</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">As it happens,
these are all optimized internally to a switch structure, so
perl jumps directly to the desired statement, and you
needn&rsquo;t worry about perl executing a lot of
unnecessary statements when you have a string of 50 elsifs,
as long as you are testing the same simple scalar variable
using ==, eq, or pattern matching as above. (If you&rsquo;re
curious as to whether the optimizer has done this for a
particular case statement, you can use the &minus;D1024
switch to list the syntax tree before execution.)</p>

<p style="margin-left:11%; margin-top: 1em"><b>Simple
statements</b></p>

<p style="margin-left:11%; margin-top: 1em">The only kind
of simple statement is an expression evaluated for its side
effects. Every expression (simple statement) must be
terminated with a semicolon. Note that this is like C, but
unlike Pascal (and <i>awk</i>).</p>

<p style="margin-left:11%; margin-top: 1em">Any simple
statement may optionally be followed by a single modifier,
just before the terminating semicolon. The possible
modifiers are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>if EXPR</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>unless EXPR</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>while EXPR</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>until EXPR</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The <i>if</i>
and <i>unless</i> modifiers have the expected semantics. The
<i>while</i> and <i>until</i> modifiers also have the
expected semantics (conditional evaluated first), except
when applied to a do-BLOCK command, in which case the block
executes once before the conditional is evaluated. This is
so that you can write loops like:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>do {</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>$_ = &lt;STDIN&gt;;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>...</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>} until $_ eq &quot;.\n&quot;;</p></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">(See the
<i>do</i> operator below. Note also that the loop control
commands described later will NOT work in this construct,
since modifiers don&rsquo;t take loop labels. Sorry.)</p>


<p style="margin-left:11%; margin-top: 1em"><b>Expressions</b></p>

<p style="margin-left:11%; margin-top: 1em">Since
<i>perl</i> expressions work almost exactly like C
expressions, only the differences will be mentioned
here.</p>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s
what <i>perl</i> has that C doesn&rsquo;t:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">**</p></td>
<td width="8%"></td>
<td width="77%">


<p style="margin-top: 1em">The exponentiation operator.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>**=</p></td>
<td width="8%"></td>
<td width="77%">


<p>The exponentiation assignment operator.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>()</p></td>
<td width="8%"></td>
<td width="77%">


<p>The null list, used to initialize an array to null.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>.</p></td>
<td width="8%"></td>
<td width="77%">


<p>Concatenation of two strings.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>.=</p></td>
<td width="8%"></td>
<td width="77%">


<p>The concatenation assignment operator.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>eq</p></td>
<td width="8%"></td>
<td width="77%">


<p>String equality (== is numeric equality). For a mnemonic
just think of &quot;eq&quot; as a string. (If you are used
to the <i>awk</i> behavior of using == for either string or
numeric equality based on the current form of the
comparands, beware! You must be explicit here.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>ne</p></td>
<td width="8%"></td>
<td width="77%">


<p>String inequality (!= is numeric inequality).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>lt</p></td>
<td width="8%"></td>
<td width="77%">


<p>String less than.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>gt</p></td>
<td width="8%"></td>
<td width="77%">


<p>String greater than.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>le</p></td>
<td width="8%"></td>
<td width="77%">


<p>String less than or equal.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>ge</p></td>
<td width="8%"></td>
<td width="77%">


<p>String greater than or equal.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>=~</p></td>
<td width="8%"></td>
<td width="77%">


<p>Certain operations search or modify the string
&quot;$_&quot; by default. This operator makes that kind of
operation work on some other string. The right argument is a
search pattern, substitution, or translation. The left
argument is what is supposed to be searched, substituted, or
translated instead of the default &quot;$_&quot;. The return
value indicates the success of the operation. (If the right
argument is an expression other than a search pattern,
substitution, or translation, it is interpreted as a search
pattern at run time. This is less efficient than an explicit
search, since the pattern must be compiled every time the
expression is evaluated.) The precedence of this operator is
lower than unary minus and autoincrement/decrement, but
higher than everything else.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>!~</p></td>
<td width="8%"></td>
<td width="77%">


<p>Just like =~ except the return value is negated.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>x</p></td>
<td width="8%"></td>
<td width="77%">


<p>The repetition operator. Returns a string consisting of
the left operand repeated the number of times specified by
the right operand.</p></td></tr>
</table>

<p style="margin-left:23%; margin-top: 1em">print
&acute;&minus;&acute; x 80; # print row of dashes</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="16%"></td>
<td width="7%">


<p>print &acute;&minus;&acute; x80;</p></td>
<td width="8%">
</td>
<td width="23%"></td>
<td width="8%"></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="16%"></td>
<td width="7%"></td>
<td width="8%">


<p># illegal, x80 is identifier</p></td>
<td width="23%"></td>
<td width="8%"></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="16%"></td>
<td width="7%">


<p>print &quot;\t&quot; x ($tab/8), &acute; &acute; x
($tab%8);</p> </td>
<td width="8%"></td>
<td width="23%"></td>
<td width="8%"></td>
<td width="23%">


<p># tab over</p></td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">x=</p></td>
<td width="9%"></td>
<td width="77%">


<p style="margin-top: 1em">The repetition assignment
operator.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>..</p></td>
<td width="9%"></td>
<td width="77%">


<p>The range operator, which is really two different
operators depending on the context. In an array context,
returns an array of values counting (by ones) from the left
value to the right value. This is useful for writing
&quot;for (1..10)&quot; loops and for doing slice operations
on arrays.</p></td></tr>
</table>

<p style="margin-left:23%; margin-top: 1em">In a scalar
context, .. returns a boolean value. The operator is
bistable, like a flip-flop.. Each .. operator maintains its
own boolean state. It is false as long as its left operand
is false. Once the left operand is true, the range operator
stays true until the right operand is true, AFTER which the
range operator becomes false again. (It doesn&rsquo;t become
false till the next time the range operator is evaluated. It
can become false on the same evaluation it became true, but
it still returns true once.) The right operand is not
evaluated while the operator is in the &quot;false&quot;
state, and the left operand is not evaluated while the
operator is in the &quot;true&quot; state. The scalar ..
operator is primarily intended for doing line number ranges
after the fashion of <i>sed</i> or <i>awk</i>. The
precedence is a little lower than &#9130;&#9130; and
&amp;&amp;. The value returned is either the null string for
false, or a sequence number (beginning with 1) for true. The
sequence number is reset for each range encountered. The
final sequence number in a range has the string
&acute;E0&acute; appended to it, which doesn&rsquo;t affect
its numeric value, but gives you something to search for if
you want to exclude the endpoint. You can exclude the
beginning point by waiting for the sequence number to be
greater than 1. If either operand of scalar .. is static,
that operand is implicitly compared to the $. variable, the
current line number. Examples:</p>

<p style="margin-left:23%; margin-top: 1em">As a scalar
operator:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p>if (101 .. 200) { print; }</p><td width="29%"></td>
<td width="-21%"></td>
<td width="38%"></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="38%">


<p># print 2nd hundred lines</p>

<p style="margin-top: 1em">next line if (1 .. /^$/);</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="-21%"></td>
<td width="38%"></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="38%">


<p># skip header lines</p>

<p style="margin-top: 1em">s/^/&gt; / if (/^$/ ..
eof());</p> </td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="-21%"></td>
<td width="38%"></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="38%">


<p># quote body</p></td></tr>
</table>

<p style="margin-left:23%; margin-top: 1em">As an array
operator:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p>for (101 .. 200) { print; }</p><td width="29%"></td>
<td width="-21%"></td>
<td width="38%"></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="38%">


<p># print $_ 100 times</p>

<p style="margin-top: 1em">@foo = @foo[$[ .. $#foo];</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="-21%"></td>
<td width="38%"></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="38%">


<p># an expensive no-op <br>
@foo = @foo[$#foo-4 .. $#foo];</p></td></tr>
<tr valign="top" align="left">
<td width="29%"></td>
<td width="-21%"></td>
<td width="38%"></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="38%">


<p># slice last 5 items</p></td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">&minus;x</p></td>
<td width="9%"></td>
<td width="77%">


<p style="margin-top: 1em">A file test. This unary operator
takes one argument, either a filename or a filehandle, and
tests the associated file to see if something is true about
it. If the argument is omitted, tests $_, except for
&minus;t, which tests <i>STDIN</i>. It returns 1 for true
and &acute;&acute; for false, or the undefined value if the
file doesn&rsquo;t exist. Precedence is higher than logical
and relational operators, but lower than arithmetic
operators. The operator may be any of:</p></td></tr>
</table>

<p style="margin-left:23%;">&minus;r File is readable by
effective uid.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>&minus;w</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>File is writable by effective uid.</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>&minus;x</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>File is executable by effective uid.</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>&minus;o</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>File is owned by effective uid.</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>&minus;R</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>File is readable by real uid.</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>&minus;W</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>File is writable by real uid.</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>&minus;X</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>File is executable by real uid.</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>&minus;O</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>File is owned by real uid.</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>&minus;e</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>File exists.</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>&minus;z</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>File has zero size.</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>&minus;s</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>File has non-zero size.</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>&minus;f</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>File is a plain file.</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>&minus;d</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>File is a directory.</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>&minus;l</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>File is a symbolic link.</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>&minus;p</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>File is a named pipe (FIFO).</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>&minus;S</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>File is a socket.</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>&minus;b</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>File is a block special file.</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>&minus;c</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>File is a character special file.</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>&minus;u</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>File has setuid bit set.</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>&minus;g</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>File has setgid bit set.</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>&minus;k</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>File has sticky bit set.</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>&minus;t</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>Filehandle is opened to a tty.</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>&minus;T</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>File is a text file.</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>&minus;B</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="77%">


<p>File is a binary file (opposite of &minus;T).</p></td></tr>
</table>

<p style="margin-left:23%; margin-top: 1em">The
interpretation of the file permission operators &minus;r,
&minus;R, &minus;w, &minus;W, &minus;x and &minus;X is based
solely on the mode of the file and the uids and gids of the
user. There may be other reasons you can&rsquo;t actually
read, write or execute the file. Also note that, for the
superuser, &minus;r, &minus;R, &minus;w and &minus;W always
return 1, and &minus;x and &minus;X return 1 if any execute
bit is set in the mode. Scripts run by the superuser may
thus need to do a stat() in order to determine the actual
mode of the file, or temporarily set the uid to something
else.</p>

<p style="margin-left:23%; margin-top: 1em">Example:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>while (&lt;&gt;) {</p></td>
<td width="23%"></td>
<td width="8%"></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="23%"></td>
<td width="8%"></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="23%"></td>
<td width="8%"></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>chop;</p></td>
<td width="23%"></td>
<td width="8%"></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="23%"></td>
<td width="8%"></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="23%"></td>
<td width="8%"></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>next unless &minus;f $_;</p></td>
<td width="23%"></td>
<td width="8%"></td>
<td width="46%">


<p># ignore specials</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="23%"></td>
<td width="8%"></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="23%"></td>
<td width="8%"></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>...</p></td>
<td width="23%"></td>
<td width="8%"></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>}</p></td>
<td width="23%"></td>
<td width="8%"></td>
<td width="46%">
</td></tr>
</table>

<p style="margin-left:23%; margin-top: 1em">Note that
&minus;s/a/b/ does not do a negated substitution. Saying
&minus;exp($foo) still works as expected, however--only
single letters following a minus are interpreted as file
tests.</p>

<p style="margin-left:23%; margin-top: 1em">The &minus;T
and &minus;B switches work as follows. The first block or so
of the file is examined for odd characters such as strange
control codes or metacharacters. If too many odd characters
(&gt;10%) are found, it&rsquo;s a &minus;B file, otherwise
it&rsquo;s a &minus;T file. Also, any file containing null
in the first block is considered a binary file. If &minus;T
or &minus;B is used on a filehandle, the current stdio
buffer is examined rather than the first block. Both
&minus;T and &minus;B return TRUE on a null file, or a file
at EOF when testing a filehandle.</p>

<p style="margin-left:11%; margin-top: 1em">If any of the
file tests (or either stat operator) are given the special
filehandle consisting of a solitary underline, then the stat
structure of the previous file test (or stat operator) is
used, saving a system call. (This doesn&rsquo;t work with
&minus;t, and you need to remember that lstat and -l will
leave values in the stat structure for the symbolic link,
not the real file.) Example:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>print &quot;Can do.\n&quot; if -r $a &#9130;&#9130; -w _
&#9130;&#9130; -x _;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>stat($filename);</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>print &quot;Readable\n&quot; if -r _;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>print &quot;Writable\n&quot; if -w _;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>print &quot;Executable\n&quot; if -x _;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>print &quot;Setuid\n&quot; if -u _;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>print &quot;Setgid\n&quot; if -g _;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>print &quot;Sticky\n&quot; if -k _;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>print &quot;Text\n&quot; if -T _;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>print &quot;Binary\n&quot; if -B _;</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Here is what C
has that <i>perl</i> doesn&rsquo;t:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p style="margin-top: 1em">unary &amp;</p></td>
<td width="7%"></td>
<td width="45%">


<p style="margin-top: 1em">Address-of operator.</p></td>
<td width="26%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p>unary *</p></td>
<td width="7%"></td>
<td width="45%">


<p>Dereference-address operator.</p></td>
<td width="26%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p>(TYPE)</p></td>
<td width="7%"></td>
<td width="45%">


<p>Type casting operator.</p></td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Like C,
<i>perl</i> does a certain amount of expression evaluation
at compile time, whenever it determines that all of the
arguments to an operator are static and have no side
effects. In particular, string concatenation happens at
compile time between literals that don&rsquo;t do variable
substitution. Backslash interpretation also happens at
compile time. You can say</p>

<p style="margin-left:11%; margin-top: 1em">&acute;Now is
the time for all&acute; . &quot;\n&quot; .</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>&acute;good men to come to.&acute;</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">and this all
reduces to one string internally.</p>

<p style="margin-left:11%; margin-top: 1em">The
autoincrement operator has a little extra built-in magic to
it. If you increment a variable that is numeric, or that has
ever been used in a numeric context, you get a normal
increment. If, however, the variable has only been used in
string contexts since it was set, and has a value that is
not null and matches the pattern
/^[a&minus;zA&minus;Z]*[0&minus;9]*$/, the increment is done
as a string, preserving each character within its range,
with carry:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="31%"></td>
<td width="8%"></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>print ++($foo = &acute;99&acute;);</p></td>
<td width="31%"></td>
<td width="8%"></td>
<td width="46%">


<p># prints &rsquo;100&rsquo;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="31%"></td>
<td width="8%"></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>print ++($foo = &acute;a0&acute;);</p></td>
<td width="31%"></td>
<td width="8%"></td>
<td width="46%">


<p># prints &rsquo;a1&rsquo;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="31%"></td>
<td width="8%"></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>print ++($foo = &acute;Az&acute;);</p></td>
<td width="31%"></td>
<td width="8%"></td>
<td width="46%">


<p># prints &rsquo;Ba&rsquo;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="31%"></td>
<td width="8%"></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>print ++($foo = &acute;zz&acute;);</p></td>
<td width="31%"></td>
<td width="8%"></td>
<td width="46%">


<p># prints &rsquo;aaa&rsquo;</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The
autodecrement is not magical.</p>
<hr>
</body>
</html>
