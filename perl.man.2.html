<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Fri Apr 19 17:26:00 2019 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>Along with the literals and variables mentioned earlier,
the operations in the following section can serve as terms
in an expression. Some of these operations take a LIST as an
argument. Such a list can consist of any combination of
scalar arguments or array values; the array values will be
included in the list as if each individual element were
interpolated at that point in the list, forming a longer
single-dimensional array value. Elements of the LIST should
be separated by commas. If an operation is listed both with
and without parentheses around its arguments, it means you
can either use it as a unary operator or as a function call.
To use it as a function call, the next token on the same
line must be a left parenthesis. (There may be intervening
white space.) Such a function then has highest precedence,
as you would expect from a function. If any token other than
a left parenthesis follows, then it is a unary operator,
with a precedence depending only on whether it is a LIST
operator or not. LIST operators have lowest precedence. All
other unary operators have a precedence greater than
relational operators but less than arithmetic operators. See
the section on Precedence. See m/PATTERN/. This is just like
the /pattern/ search, except that it matches only once
between calls to the operator. This is a useful optimization
when you only want to see the first occurrence of something
in each file of a set of files, for instance. Only ??
patterns local to the current package are reset. Does the
same thing that the accept system call does. Returns true if
it succeeded, false otherwise. See example in section on
Interprocess Communication. Returns the arctangent of X/Y in
the range &minus;PI to PI. Does the same thing that the bind
system call does. Returns true if it succeeded, false
otherwise. NAME should be a packed address of the proper
type for the socket. See example in section on Interprocess
Communication. Changes the working directory to EXPR, if
possible. If EXPR is omitted, changes to home directory.
Returns 1 upon success, 0 otherwise. See example under
Changes the permissions of a list of files. The first
element of the list must be the numerical mode. Returns the
number of files successfully changed.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>$cnt = chmod 0755, &acute;foo&acute;,
&acute;bar&acute;;</p> </td>
<td width="85%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>chmod 0755, @executables;</p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-top: 1em">Chops off the last character of
a string and returns the character chopped. It&rsquo;s used
primarily to remove the newline from the end of an input
record, but is much more efficient than s/\n// because it
neither scans nor copies the string. If VARIABLE is omitted,
chops $_. Example:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>while (&lt;&gt;) {</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>chop;</p></td>
<td width="8%"></td>
<td width="7%">


<p># avoid \n on last field</p></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>@array = split(/:/);</p></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>...</p></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>}</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
</table>

<p style="margin-top: 1em">You can actually chop anything
that&rsquo;s an lvalue, including an assignment:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>chop($cwd = `pwd`);</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>chop($answer = &lt;STDIN&gt;);</p></td></tr>
</table>

<p style="margin-top: 1em">If you chop a list, each element
is chopped. Only the value of the last chop is returned.
Changes the owner (and group) of a list of files. The first
two elements of the list must be the NUMERICAL uid and gid,
in that order. Returns the number of files successfully
changed.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>$cnt = chown $uid, $gid, &acute;foo&acute;,
&acute;bar&acute;;</p> </td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>chown $uid, $gid, @filenames;</p></td></tr>
</table>

<p style="margin-top: 1em">Here&rsquo;s an example of
looking up non-numeric uids:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>print &quot;User: &quot;;</p></td>
<td width="8%"></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>$user = &lt;STDIN&gt;;</p></td>
<td width="8%"></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>chop($user);</p></td>
<td width="8%"></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>print &quot;Files: &quot;</p></td>
<td width="8%"></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>$pattern = &lt;STDIN&gt;;</p></td>
<td width="8%"></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>chop($pattern);</p></td>
<td width="8%"></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>open(pass, &acute;/etc/passwd&acute;) || die
&quot;Can&rsquo;t open passwd: $!\n&quot;;</p></td>
<td width="8%"></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>while (&lt;pass&gt;) {</p></td>
<td width="8%"></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>($login,$pass,$uid,$gid) = split(/:/);</p></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>$uid{$login} = $uid;</p></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>$gid{$login} = $gid;</p></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>}</p></td>
<td width="8%"></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>@ary = &lt;$pattern&gt;;</p></td>
<td width="8%"></td>
<td width="15%"></td>
<td width="8%">


<p># get filenames</p></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>if ($uid{$user} eq &acute;&acute;) {</p></td>
<td width="8%"></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>die &quot;$user not in passwd file&quot;;</p></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>}</p></td>
<td width="8%"></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>else {</p></td>
<td width="8%"></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>chown $uid{$user}, $gid{$user}, @ary;</p></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>}</p></td>
<td width="8%"></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
</table>

<p style="margin-top: 1em">Does the same as the system call
of that name. If you don&rsquo;t know what it does,
don&rsquo;t worry about it. If FILENAME is omitted, does
chroot to $_. Closes the file or pipe associated with the
file handle. You don&rsquo;t have to close FILEHANDLE if you
are immediately going to do another open on it, since open
will close it for you. (See However, an explicit close on an
input file resets the line counter ($.), while the implicit
close done by does not. Also, closing a pipe will wait for
the process executing on the pipe to complete, in case you
want to look at the output of the pipe afterwards. Closing a
pipe explicitly also puts the status value of the command
into $?. Example:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>open(OUTPUT, &acute;|sort &gt;foo&acute;);</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="8%">


<p># pipe to sort</p></td>
<td width="38%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>...</p></td>
<td width="8%">


<p># print stuff to output</p></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="38%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>close OUTPUT;</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p># wait for sort to finish</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="38%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>open(INPUT, &acute;foo&acute;);</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p># get sort&rsquo;s results</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="38%">
</td></tr>
</table>

<p style="margin-top: 1em">FILEHANDLE may be an expression
whose value gives the real filehandle name. Closes a
directory opened by opendir(). Does the same thing that the
connect system call does. Returns true if it succeeded,
false otherwise. NAME should be a package address of the
proper type for the socket. See example in section on
Interprocess Communication. Returns the cosine of EXPR
(expressed in radians). If EXPR is omitted takes cosine of
$_. Encrypts a string exactly like the crypt() function in
the C library. Useful for checking the password file for
lousy passwords. Only the guys wearing white hats should do
this. Breaks the binding between a dbm file and an
associative array. The values remaining in the associative
array are meaningless unless you happen to want to know what
was in the cache for the dbm file. This function is only
useful if you have ndbm. This binds a dbm or ndbm file to an
associative array. ASSOC is the name of the associative
array. (Unlike normal open, the first argument is NOT a
filehandle, even though it looks like one). DBNAME is the
name of the database (without the .dir or .pag extension).
If the database does not exist, it is created with
protection specified by MODE (as modified by the umask). If
your system only supports the older dbm functions, you may
only have one dbmopen in your program. If your system has
neither dbm nor ndbm, calling dbmopen produces a fatal
error. Values assigned to the associative array prior to the
dbmopen are lost. A certain number of values from the dbm
file are cached in memory. By default this number is 64, but
you can increase it by preallocating that number of garbage
entries in the associative array before the dbmopen. You can
flush the cache if necessary with the reset command. If you
don&rsquo;t have write access to the dbm file, you can only
read associative array variables, not set them. If you want
to test whether you can write, either use file tests or try
setting a dummy array entry inside an eval, which will trap
the error. Note that functions such as keys() and values()
may return huge array values when used on large dbm files.
You may prefer to use the each() function to iterate over
large dbm files. Example:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p># print out history file offsets</p></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">



<p>dbmopen(HIST,&rsquo;/usr/lib/news/history&rsquo;,0666);</p> </td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>while (($key,$val) = each %HIST) {</p></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>print $key, &rsquo; = &rsquo;,
unpack(&rsquo;L&rsquo;,$val), &quot;\n&quot;;</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>}</p></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>dbmclose(HIST);</p></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-top: 1em">Returns a boolean value saying
whether the lvalue EXPR has a real value or not. Many
operations return the undefined value under exceptional
conditions, such as end of file, uninitialized variable,
system error and such. This function allows you to
distinguish between an undefined null string and a defined
null string with operations that might return a real null
string, in particular referencing elements of an array. You
may also check to see if arrays or subroutines exist. Use on
predefined variables is not guaranteed to produce intuitive
results. Examples:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>print if defined $switch{&rsquo;D&rsquo;};</p></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>print &quot;$val\n&quot; while defined($val =
pop(@ary));</p> </td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>die &quot;Can&rsquo;t readlink $sym: $!&quot;</p></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>unless defined($value = readlink $sym);</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>eval &rsquo;@foo = ()&rsquo; if defined(@foo);</p></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>die &quot;No XYZ package defined&quot; unless defined
%_XYZ;</p> </td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>sub foo { defined &amp;bar ? &amp;bar(@_) : die &quot;No
bar&quot;; }</p></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-top: 1em">See also undef. Deletes the
specified value from the specified associative array.
Returns the deleted value, or the undefined value if nothing
was deleted. Deleting from $ENV{} modifies the environment.
Deleting from an array bound to a dbm file deletes the entry
from the dbm file. The following deletes all the values of
an associative array:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>foreach $key (keys %ARRAY) {</p></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>delete $ARRAY{$key};</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>}</p></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-top: 1em">(But it would be faster to use
the command. Saying undef %ARRAY is faster yet.) Prints the
value of LIST to and exits with the current value of $!
(errno). If $! is 0, exits with the value of ($? &gt;&gt; 8)
(`command` status). If ($? &gt;&gt; 8) is 0, exits with 255.
Equivalent examples:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>die &quot;Can&rsquo;t cd to spool: $!\n&quot; unless
chdir &acute;/usr/spool/news&acute;;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>chdir &acute;/usr/spool/news&acute; || die
&quot;Can&rsquo;t cd to spool: $!\n&quot;</p></td></tr>
</table>

<p style="margin-top: 1em">If the value of EXPR does not
end in a newline, the current script line number and input
line number (if any) are also printed, and a newline is
supplied. Hint: sometimes appending , stopped to your
message will cause it to make better sense when the string
at foo line 123 is appended. Suppose you are running script
canasta.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>die &quot;/etc/games is no good&quot;;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>die &quot;/etc/games is no good, stopped&quot;;</p></td></tr>
</table>

<p style="margin-top: 1em">produce, respectively</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>/etc/games is no good at canasta line 123.</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>/etc/games is no good, stopped at canasta line 123.</p></td></tr>
</table>

<p style="margin-top: 1em">See also Returns the value of
the last command in the sequence of commands indicated by
BLOCK. When modified by a loop modifier, executes the BLOCK
once before testing the loop condition. (On other statements
the loop modifiers test the conditional first.) Executes a
SUBROUTINE declared by a declaration, and returns the value
of the last expression evaluated in SUBROUTINE. If there is
no subroutine by that name, produces a fatal error. (You may
use the defined operator to determine if a subroutine
exists.) If you pass arrays as part of LIST you may wish to
pass the length of the array in front of each array. (See
the section on subroutines later on.) SUBROUTINE may be a
scalar variable, in which case the variable contains the
name of the subroutine to execute. The parentheses are
required to avoid confusion with the do EXPR form. As an
alternate form, you may call a subroutine by prefixing the
name with an ampersand: &amp;foo(@args). If you aren&rsquo;t
passing any arguments, you don&rsquo;t have to use
parentheses. If you omit the parentheses, no @_ array is
passed to the subroutine. The &amp; form is also used to
specify subroutines to the defined and undef operators. Uses
the value of EXPR as a filename and executes the contents of
the file as a script. Its primary use is to include
subroutines from a subroutine library.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>do &acute;stat.pl&acute;;</p></td></tr>
</table>

<p style="margin-top: 1em">is just like</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>eval `cat stat.pl`;</p></td></tr>
</table>

<p style="margin-top: 1em">except that it&rsquo;s more
efficient, more concise, keeps track of the current filename
for error messages, and searches all the libraries if the
file isn&rsquo;t in the current directory (see also the @INC
array in Predefined Names). It&rsquo;s the same, however, in
that it does reparse the file every time you call it, so if
you are going to use the file inside a loop you might prefer
to use &minus;P and #include, at the expense of a little
more startup time. (The main problem with #include is that
cpp doesn&rsquo;t grok # commentsa workaround is to use ;#
for standalone comments.) Note that the following are NOT
equivalent:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>do $foo;</p></td>
<td width="8%"></td>
<td width="8%">


<p># eval a file</p></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>do $foo();</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="7%">


<p># call a subroutine</p></td>
<td width="62%">
</td></tr>
</table>

<p style="margin-top: 1em">This causes an immediate core
dump. Primarily this is so that you can use the undump
program to turn your core dump into an executable binary
after having initialized all your variables at the beginning
of the program. When the new binary is executed it will
begin by executing a &quot;goto LABEL&quot; (with all the
restrictions that goto suffers). Think of it as a goto with
an intervening core dump and reincarnation. If LABEL is
omitted, restarts the program from the top. WARNING: any
files opened at the time of the dump will NOT be open any
more when the program is reincarnated, with possible
resulting confusion on the part of perl. See also &minus;u.
Example:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>#!/usr/bin/perl</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>do &rsquo;getopt.pl&rsquo;;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>do &rsquo;stat.pl&rsquo;;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>%days = (</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>&rsquo;Sun&rsquo;,1,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>&rsquo;Mon&rsquo;,2,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>&rsquo;Tue&rsquo;,3,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>&rsquo;Wed&rsquo;,4,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>&rsquo;Thu&rsquo;,5,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>&rsquo;Fri&rsquo;,6,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>&rsquo;Sat&rsquo;,7);</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>dump QUICKSTART if $ARGV[0] eq &rsquo;-d&rsquo;;</p></td></tr>
</table>

<p style="margin-top: 1em">QUICKSTART:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>do Getopt(&rsquo;f&rsquo;);</p></td></tr>
</table>

<p style="margin-top: 1em">Returns a 2 element array
consisting of the key and value for the next value of an
associative array, so that you can iterate over it. Entries
are returned in an apparently random order. When the array
is entirely read, a null array is returned (which when
assigned produces a FALSE (0) value). The next call to
each() after that will start iterating again. The iterator
can be reset only by reading all the elements from the
array. You must not modify the array while iterating over
it. There is a single iterator for each associative array,
shared by all each(), keys() and values() function calls in
the program. The following prints out your environment like
the printenv program, only in a different order:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>while (($key,$value) = each %ENV) {</p></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>print &quot;$key=$value\n&quot;;</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>}</p></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-top: 1em">See also keys() and values().
Returns 1 if the next read on FILEHANDLE will return end of
file, or if FILEHANDLE is not open. FILEHANDLE may be an
expression whose value gives the real filehandle name. An
eof without an argument returns the eof status for the last
file read. Empty parentheses () may be used to indicate the
pseudo file formed of the files listed on the command line,
i.e. eof() is reasonable to use inside a while (&lt;&gt;)
loop to detect the end of only the last file. Use eof(ARGV)
or eof without the parentheses to test EACH file in a while
(&lt;&gt;) loop. Examples:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p># insert dashes just before last line of last file</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>while (&lt;&gt;) {</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>if (eof()) {</p></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">


<p>print
&quot;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;\n&quot;;</p> </td>
<td width="7%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>}</p></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>print;</p></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>}</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p># reset line numbering on each input file</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>while (&lt;&gt;) {</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>print &quot;$.\t$_&quot;;</p></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>if (eof) {</p></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p># Not eof().</p></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">


<p>close(ARGV);</p></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>}</p></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>}</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="54%">
</td></tr>
</table>

<p style="margin-top: 1em">EXPR is parsed and executed as
if it were a little program. It is executed in the context
of the current program, so that any variable settings,
subroutine or format definitions remain afterwards. The
value returned is the value of the last expression
evaluated, just as with subroutines. If there is a syntax
error or runtime error, a null string is returned by eval,
and $@ is set to the error message. If there was no error,
$@ is null. If EXPR is omitted, evaluates $_. The final
semicolon, if any, may be omitted from the expression. Note
that, since eval traps otherwise-fatal errors, it is useful
for determining whether a particular feature (such as
dbmopen or symlink) is implemented. If there is more than
one argument in LIST, or if LIST is an array with more than
one value, calls execvp() with the arguments in LIST. If
there is only one scalar argument, the argument is checked
for shell metacharacters. If there are any, the entire
argument is passed to /bin/sh &minus;c for parsing. If there
are none, the argument is split into words and passed
directly to execvp(), which is more efficient. Note: exec
(and system) do not flush your output buffer, so you may
need to set $| to avoid lost output. Examples:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>exec &acute;/bin/echo&acute;, &acute;Your arguments are:
&acute;, @ARGV;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>exec &quot;sort $outfile | uniq&quot;;</p></td></tr>
</table>

<p style="margin-top: 1em">If you don&rsquo;t really want
to execute the first argument, but want to lie to the
program you are executing about its own name, you can
specify the program you actually want to run by assigning
that to a variable and putting the name of the variable in
front of the LIST without a comma. (This always forces
interpretation of the LIST as a multi-valued list, even if
there is only a single scalar in the list.) Example:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>$shell = &rsquo;/bin/csh&rsquo;;</p></td>
<td width="23%"></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>exec $shell &rsquo;-sh&rsquo;;</p></td>
<td width="23%"></td>
<td width="8%">
</td>
<td width="8%">


<p># pretend it&rsquo;s a login shell</p></td>
<td width="46%">
</td></tr>
</table>

<p style="margin-top: 1em">Evaluates EXPR and exits
immediately with that value. Example:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>$ans = &lt;STDIN&gt;;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>exit 0 if $ans =~ /^[Xx]/;</p></td></tr>
</table>

<p style="margin-top: 1em">See also If EXPR is omitted,
exits with 0 status. Returns to the power of EXPR. If EXPR
is omitted, gives exp($_). Implements the fcntl(2) function.
You&rsquo;ll probably have to say</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>do &quot;fcntl.h&quot;;</p></td>
<td width="16%"></td>
<td width="7%">


<p># probably /usr/local/lib/perl/fcntl.h</p></td>
<td width="62%">
</td></tr>
</table>

<p style="margin-top: 1em">first to get the correct
function definitions. If fcntl.h doesn&rsquo;t exist or
doesn&rsquo;t have the correct definitions you&rsquo;ll have
to roll your own, based on your C header files such as
&lt;sys/fcntl.h&gt;. (There is a perl script called makelib
that comes with the perl kit which may help you in this.)
Argument processing and value return works just like ioctl
below. Note that fcntl will produce a fatal error if used on
a machine that doesn&rsquo;t implement fcntl(2). Returns the
file descriptor for a filehandle. Useful for constructing
bitmaps for select(). If FILEHANDLE is an expression, the
value is taken as the name of the filehandle. Calls flock(2)
on FILEHANDLE. See manual page for flock(2) for definition
of OPERATION. Will produce a fatal error if used on a
machine that doesn&rsquo;t implement flock(2). Here&rsquo;s
a mailbox appender for BSD systems.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>$LOCK_SH = 1;</p></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>$LOCK_EX = 2;</p></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>$LOCK_NB = 4;</p></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>$LOCK_UN = 8;</p></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>sub lock {</p></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>flock(MBOX,$LOCK_EX);</p></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p># and, in case someone appended</p></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p># while we were waiting...</p></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>seek(MBOX, 0, 2);</p></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>}</p></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>sub unlock {</p></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>flock(MBOX,$LOCK_UN);</p></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>}</p></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>open(MBOX,
&quot;&gt;&gt;/usr/spool/mail/$USER&quot;)</p> </td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>|| die &quot;Can&rsquo;t open mailbox: $!&quot;;</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>do lock();</p></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>print MBOX $msg,&quot;\n\n&quot;;</p></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>do unlock();</p></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-top: 1em">Does a fork() call. Returns the
child pid to the parent process and 0 to the child process.
Note: unflushed buffers remain unflushed in both processes,
which means you may need to set $| to avoid duplicate
output. Returns the next character from the input file
attached to FILEHANDLE, or a null string at EOF. If
FILEHANDLE is omitted, reads from STDIN. Returns the current
login from /etc/utmp, if any. If null, use getpwuid.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>($login = getlogin) || (($login) = getpwuid($&lt;));</p></td></tr>
</table>

<p style="margin-top: 1em">Returns the packed sockaddr
address of other end of the SOCKET connection.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p># An internet sockaddr</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>$sockaddr = &rsquo;S n a4 x8&rsquo;;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>$hersockaddr = getpeername(S);</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>($family, $port, $heraddr) =
unpack($sockaddr,$hersockaddr);</p> </td></tr>
</table>

<p style="margin-top: 1em">Returns the current process
group for the specified PID, 0 for the current process. Will
produce a fatal error if used on a machine that
doesn&rsquo;t implement getpgrp(2). If EXPR is omitted,
returns process group of current process. Returns the
process id of the parent process. Returns the current
priority for a process, a process group, or a user. (See
getpriority(2).) Will produce a fatal error if used on a
machine that doesn&rsquo;t implement getpriority(2). These
routines perform the same functions as their counterparts in
the system library. The return values from the various get
routines are as follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>($name,$passwd,$uid,$gid,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>$quota,$comment,$gcos,$dir,$shell) = getpw...</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>($name,$passwd,$gid,$members) = getgr...</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>($name,$aliases,$addrtype,$length,@addrs) =
gethost...</p> </td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>($name,$aliases,$addrtype,$net) = getnet...</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>($name,$aliases,$proto) = getproto...</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>($name,$aliases,$port,$proto) = getserv...</p></td></tr>
</table>

<p style="margin-top: 1em">The $members value returned by
getgr... is a space separated list of the login names of the
members of the group. The @addrs value returned by the
gethost... functions is a list of the raw addresses returned
by the corresponding system library call. In the Internet
domain, each address is four bytes long and you can unpack
it by saying something like:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>($a,$b,$c,$d) = unpack(&rsquo;C4&rsquo;,$addr[0]);</p></td></tr>
</table>

<p style="margin-top: 1em">Returns the packed sockaddr
address of this end of the SOCKET connection.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p># An internet sockaddr</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>$sockaddr = &rsquo;S n a4 x8&rsquo;;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>$mysockaddr = getsockname(S);</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>($family, $port, $myaddr) =
unpack($sockaddr,$mysockaddr);</p> </td></tr>
</table>

<p style="margin-top: 1em">Returns the socket option
requested, or undefined if there is an error. Converts a
time as returned by the time function to a 9-element array
with the time analyzed for the Greenwich timezone. Typically
used as follows:</p>


<p style="margin-top: 1em">($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)
= gmtime(time);</p>

<p style="margin-top: 1em">All array elements are numeric,
and come straight out of a struct tm. In particular this
means that $mon has the range 0..11 and $wday has the range
0..6. If EXPR is omitted, does gmtime(time). Finds the
statement labeled with LABEL and resumes execution there.
Currently you may only go to statements in the main body of
the program that are not nested inside a do {} construct.
This statement is not implemented very efficiently, and is
here only to make the translator easier. I may change its
semantics at any time, consistent with support for
translated scripts. Use it at your own risk. Better yet,
don&rsquo;t use it at all. Evaluates EXPR for each element
of LIST (locally setting $_ to each element) and returns the
array value consisting of those elements for which the
expression evaluated to true.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>@foo = grep(!/^#/, @bar); # weed out comments</p></td></tr>
</table>

<p style="margin-top: 1em">Returns the decimal value of
EXPR interpreted as an hex string. (To interpret strings
that might start with 0 or 0x see oct().) If EXPR is
omitted, uses $_. Implements the ioctl(2) function.
You&rsquo;ll probably have to say</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>do &quot;ioctl.h&quot;;</p></td>
<td width="16%"></td>
<td width="7%">


<p># probably /usr/local/lib/perl/ioctl.h</p></td>
<td width="62%">
</td></tr>
</table>

<p style="margin-top: 1em">first to get the correct
function definitions. If ioctl.h doesn&rsquo;t exist or
doesn&rsquo;t have the correct definitions you&rsquo;ll have
to roll your own, based on your C header files such as
&lt;sys/ioctl.h&gt;. (There is a perl script called makelib
that comes with the perl kit which may help you in this.)
SCALAR will be read and/or written depending on the
FUNCTIONa pointer to the string value of SCALAR will be
passed as the third argument of the actual ioctl call. (If
SCALAR has no string value but does have a numeric value,
that value will be passed rather than a pointer to the
string value. To guarantee this to be true, add a 0 to the
scalar before using it.) The pack() and unpack() functions
are useful for manipulating the values of structures used by
ioctl(). The following example sets the erase character to
DEL.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>do &rsquo;ioctl.h&rsquo;;</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="38%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>$sgttyb_t = &quot;ccccs&quot;;</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="15%"></td>
<td width="8%">
</td>
<td width="8%">


<p># 4 chars and a short</p></td>
<td width="38%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>if (ioctl(STDIN,$TIOCGETP,$sgttyb)) {</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="38%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>@ary = unpack($sgttyb_t,$sgttyb);</p></td>
<td width="8%"></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="38%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>$ary[2] = 127;</p></td>
<td width="8%"></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="38%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>$sgttyb = pack($sgttyb_t,@ary);</p></td>
<td width="8%"></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="38%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>ioctl(STDIN,$TIOCSETP,$sgttyb)</p></td>
<td width="8%"></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="38%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">


<p>|| die &quot;Can&rsquo;t ioctl: $!&quot;;</p></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="38%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>}</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="15%"></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="38%">
</td></tr>
</table>

<p style="margin-top: 1em">The return value of ioctl (and
fcntl) is as follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>if OS returns: perl returns:</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>-1 undefined value</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>0 string &quot;0 but true&quot;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>anything else that number</p></td></tr>
</table>

<p style="margin-top: 1em">Thus perl returns true on
success and false on failure, yet you can still easily
determine the actual value returned by the operating
system:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>($retval = ioctl(...)) || ($retval = -1);</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>printf &quot;System returned %d\n&quot;, $retval;</p></td></tr>
</table>

<p>Returns the position of the first occurrence of SUBSTR
in STR, based at 0, or whatever you&rsquo;ve set the $[
variable to. If the substring is not found, returns one less
than the base, ordinarily &minus;1. Returns the integer
portion of EXPR. If EXPR is omitted, uses $_. Joins the
separate strings of LIST or ARRAY into a single string with
fields separated by the value of EXPR, and returns the
string. Example:</p>

<p style="margin-top: 1em">$_ = join(&acute;:&acute;,
$login,$passwd,$uid,$gid,$gcos,$home,$shell);</p>

<p style="margin-top: 1em">See Returns a normal array
consisting of all the keys of the named associative array.
The keys are returned in an apparently random order, but it
is the same order as either the values() or each() function
produces (given that the associative array has not been
modified). Here is yet another way to print your
environment:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>@keys = keys %ENV;</p></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>@values = values %ENV;</p></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>while ($#keys &gt;= 0) {</p></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>print pop(keys), &acute;=&acute;, pop(values),
&quot;\n&quot;;</p> </td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>}</p></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-top: 1em">or how about sorted by key:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>foreach $key (sort(keys %ENV)) {</p></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>print $key, &acute;=&acute;, $ENV{$key},
&quot;\n&quot;;</p> </td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>}</p></td>
<td width="8%"></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-top: 1em">Sends a signal to a list of
processes. The first element of the list must be the signal
to send. Returns the number of processes successfully
signaled.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>$cnt = kill 1, $child1, $child2;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>kill 9, @goners;</p></td></tr>
</table>

<p style="margin-top: 1em">If the signal is negative, kills
process groups instead of processes. (On System V, a
negative <i>process</i> number will also kill process
groups, but that&rsquo;s not portable.) You may use a signal
name in quotes. The command is like the statement in C (as
used in loops); it immediately exits the loop in question.
If the LABEL is omitted, the command refers to the innermost
enclosing loop. The block, if any, is not executed:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>line: while (&lt;STDIN&gt;) {</p></td>
<td width="8%"></td>
<td width="23%"></td>
<td width="8%"></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>last line if /^$/;</p></td>
<td width="23%"></td>
<td width="8%">


<p># exit when done with header</p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>...</p></td>
<td width="23%"></td>
<td width="8%"></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>}</p></td>
<td width="8%"></td>
<td width="23%"></td>
<td width="8%"></td>
<td width="46%">
</td></tr>
</table>

<p style="margin-top: 1em">Returns the length in characters
of the value of EXPR. If EXPR is omitted, returns length of
$_. Creates a new filename linked to the old filename.
Returns 1 for success, 0 otherwise. Does the same thing that
the listen system call does. Returns true if it succeeded,
false otherwise. See example in section on Interprocess
Communication. Declares the listed variables to be local to
the enclosing block, subroutine, eval or do. All the listed
elements must be legal lvalues. This operator works by
saving the current values of those variables in LIST on a
hidden stack and restoring them upon exiting the block,
subroutine or eval. This means that called subroutines can
also reference the local variable, but not the global one.
The LIST may be assigned to if desired, which allows you to
initialize your local variables. (If no initializer is
given, all scalars are initialized to the null string and
all arrays and associative arrays to the null array.)
Commonly this is used to name the parameters to a
subroutine. Examples:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>sub RANGEVAL {</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>local($min, $max, $thunk) = @_;</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>local($result) = &acute;&acute;;</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>local($i);</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p># Presumably $thunk makes reference to $i</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>for ($i = $min; $i &lt; $max; $i++) {</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">


<p>$result .= eval $thunk;</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>}</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>$result;</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>}</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>if ($sw eq &acute;-v&acute;) {</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p># init local array with global array</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>local(@ARGV) = @ARGV;</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>unshift(&acute;echo&acute;,@ARGV);</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>system @ARGV;</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>}</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p># @ARGV restored</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p># temporarily add to digits associative array</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>if ($base12) {</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p># (NOTE: not claiming this is efficient!)</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>local(%digits) =
(%digits,&rsquo;t&rsquo;,10,&rsquo;e&rsquo;,11);</p> </td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>do parse_num();</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>}</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
</table>

<p style="margin-top: 1em">Note that local() is a run-time
command, and so gets executed every time through a loop,
using up more stack storage each time until it&rsquo;s all
released at once when the loop is exited. Converts a time as
returned by the time function to a 9-element array with the
time analyzed for the local timezone. Typically used as
follows:</p>


<p style="margin-top: 1em">($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)
= localtime(time);</p>

<p style="margin-top: 1em">All array elements are numeric,
and come straight out of a struct tm. In particular this
means that $mon has the range 0..11 and $wday has the range
0..6. If EXPR is omitted, does localtime(time). Returns
logarithm (base of EXPR. If EXPR is omitted, returns log of
$_. Does the same thing as the stat() function, but stats a
symbolic link instead of the file the symbolic link points
to. If symbolic links are unimplemented on your system, a
normal stat is done. Searches a string for a pattern match,
and returns true (1) or false (&acute;&acute;). If no string
is specified via the =~ or !~ operator, the $_ string is
searched. (The string specified with =~ need not be an
lvalueit may be the result of an expression evaluation, but
remember the =~ binds rather tightly.) See also the section
on regular expressions. If / is the delimiter then the
initial m is optional. With the m you can use any pair of
characters as delimiters. This is particularly useful for
matching Unix path names that contain /. If the final
delimiter is followed by the optional letter i, the matching
is done in a case-insensitive manner. PATTERN may contain
references to scalar variables, which will be interpolated
(and the pattern recompiled) every time the pattern search
is evaluated. If you want such a pattern to be compiled only
once, add an o after the trailing delimiter. This avoids
expensive run-time recompilations, and is useful when the
value you are interpolating won&rsquo;t change over the life
of the script. If used in a context that requires an array
value, a pattern match returns an array consisting of the
subexpressions matched by the parentheses in the pattern,
i.e. ($1, $2, $3...). It does NOT actually set $1, $2, etc.
in this case, nor does it set $+, $&lsquo;, $&amp; or
$&rsquo;. If the match fails, a null array is returned.
Examples:</p>

<p style="margin-top: 1em">open(tty,
&acute;/dev/tty&acute;);</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p>&lt;tty&gt; =~ /^y/i &amp;&amp; do foo();</p><td width="6%"></td>
<td width="2%"></td>
<td width="46%"></td>
<td width="8%">


<p># do foo if desired</p></td>
<td width="38%">
</td></tr>
</table>

<p style="margin-top: 1em">if (/Version: *([0&minus;9.]*)/)
{ $version = $1; }</p>

<p style="margin-top: 1em">next if m#^/usr/spool/uucp#;</p>

<p style="margin-top: 1em"># poor man&rsquo;s grep <br>
$arg = shift; <br>
while (&lt;&gt;) {</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>print if /$arg/o;</p></td>
<td width="31%"></td>
<td width="8%">


<p># compile only once</p></td>
<td width="46%">
</td></tr>
</table>

<p>}</p>

<p style="margin-top: 1em">if (($F1, $F2, $Etc) = ($foo =~
/^(\S+)\s+(\S+)\s*(.*)/))</p>

<p style="margin-top: 1em">This last example splits $foo
into the first two words and the remainder of the line, and
assigns those three fields to $F1, $F2 and $Etc. The
conditional is true if any variables were assigned, i.e. if
the pattern matched. Creates the directory specified by
FILENAME, with permissions specified by MODE (as modified by
umask). If it succeeds it returns 1, otherwise it returns 0
and sets $! (errno).</p>
<hr>
</body>
</html>
